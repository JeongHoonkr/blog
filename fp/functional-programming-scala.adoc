= 함수형 프로그래밍(Functional Programming with Scala)

=== 함수형 프로그래밍
* 순수 함수(Pure Function)로만 이루어진 프로그램
* 부수 효과(Side Effect)가 없는 함수로 이루어짐

===== 순수 함수가 무엇일까?
* 부수 효과가 없는 함수
* 항상 같은 값을 돌려줌
* 참조 투명성
** 표현식(값을 반환하는 코드 단위)의 한 속성
* 합성 가능
** 결과와 입력이 분리되어 있기 때문에 함수들을 조합할 수 있음

===== 부수효과가 무엇일까?
* 변수를 수정함
* 객체 필드를 설정함
* 예외를 던지거나 오류를 내면서 실행을 중단함
* 콘솔 출력, 사용자 입력을 받음
* 파일을 읽거나 기록함
* 화면을 그림

[source, scala]
----
// 참조 투명성
// 값 2, 값 3, 순수함수 + 적용 (모두 다 표현식)
// 항상 5라는 결과를 출력
// 프로그램에 있는 2 + 3 을 값 5로 바꾸어도 프로그램 의미가 바뀌지 않음
scala> 2 + 3
res0: Int = 5
----

=== 임의의 상태 있는 API를 순수 함수적으로 만들어 보자

===== 난수 발생 => 부수효과가 있는 프로그램
* 객체 rng에서 메서드 호출할 때마다 상태가 갱신되는 내부가 존재함
* 상태 갱신은 부수효과를 수행함(= 참조 투명하지 않음)
* 참조 투명하지 않은 함수 
** 검사, 합성, 모듈화, 병렬화가 어려움

[source, scala]
----
// scala.util.Random 발생
// 난수 발생기 단순하지만, 프로그램이 복잡해지면 버그가 났을 때 재현이 힘듬
// 오류가 났을 때 동일한 난수 발생기(Seed, 기타 내부상태가 동일해야함) 전달하기만 하면 됨
scala> var rng = new scala.util.Random
rng: scala.util.Random = scala.util.Random@4996c99

scala> rng.nextDouble
res0: Double = 0.8670415402258371

scala> rng.nextInt
res1: Int = 236054598
----

===== 순수 함수적 난수 발생
* 참조 투명성을 살리기 위해서 상태 갱신을 _명시적으로_ 드러내는 것
** 새 상태를 발생한 난수와 함께 돌려줌
* 관심사 분리
** 다음 상태를 계산하는 관심사
** 새 상태를 프로그램 나머지 부분에 알려주는 관심사

===== 상태 동작을 위한 더 나은 API
* 상태 동작(State Action), 상태 전이(State Transition) 
** 모든 함수가 어떤 형식 A에 대해 RNG => (A, RNG) 형태의 형식을 사용한다는 공통 패턴 발견
* 직접 호출하는 것보다 고차 함수인 _조합기(Combinator)_ 이용하여 조합기를 통해 상태를 넘겨주는 것이 좋음

===== 일반적 상태 동작 자료 형식
* **State** 
** 어떤 상태를 유지하는 계산. 즉, 상태 동작 또는 상태 전이를 대표함

===== 순수 함수적 명령식 프로그래밍
* 상태 동작 실행, 결과를 val 담고 그 val을 사용하는 다른 상태 동작을 실행하고 그 결과를 또 다른 val에 담는 방식이 _명령식 프로그래밍_ 과 비슷함

===== 정리
* 효과 있는 계산의 서술(Description)을 순수 함수를 이용해서 계산하고, 그 서술을 개별적인 해석기(Interpreter)를 이용해 실행함으로써 효과를 실행함
* Machine 예제 코드를 통해서 coinTr 함수는 들어온 코인을 계산하고 다음 상태를 전달, turnTr 함수는 버튼 누른 수를 계산하고 다음 상태로 전달, inputTr 함수는 코인, 버튼을 계산하고 다음 상태로 전달하는 역할, sequence 등 조합기를 통해 필요한 기능을 조합하고 run 함수로 단순히 실행하는 역할을 각각 분리해서 부수효과가 발생하지 않은 프로그램을 개발할 수 있는 것을 확인함 

=== 참고
* 스칼라로 배우는 함수형 프로그래밍 책으로 신림 스터디 진행한 후, 정리 중:)
