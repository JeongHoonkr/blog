= 클린코드 

=== 1. 깨끗한 코드

===== 코드가 존재하리라 
* 코드는 요구사항을 표현하는 언어라는 사실을 명심할 것
* 하지만, 어느 순간에 정밀한 표현이 필요함. 그 필요성을 없앨 방법은 없으므로 코드도 항상 존재하리라!

===== 나쁜 코드
* 자기가 짠 쓰레기 코드를 보면서 나중에 손보겠다고 결심한 경험, 대충 짠 프로그램이 돌아간다는 사실의 안도한 경험
* 나중에 고치겠다고 다짐하지만
* 르블랑의 법칙을 모른 채, 나중에 고치겠다던 시간은 돌아오지 않음

===== 나쁜 코드로 치르는 대가

* 원대한 재설계의 꿈
** 새 팀을 꾸린다는 것은 처음부터 시작해 진정으로 아름다운 작품을 창조할 수 있는 기회
** 하지만, 새 시스템 설계 및 기존 시스템에 변경사항 모두 따라잡아야 함
** 새 시스템이 기존 시스템을 따라잡을 즈음이면 모든 팀원이 나가고 새로운 팀원으로 그 자리를 채움
** 그렇게 만들어진 시스템은 엉망이기 때문에 다른 시스템을 구축하게 됨

* 태도
** 좋은 코드가 한순간 나쁜 코드로 전락할까?
*** 잘못은 전적으로 프로그래머에게 있음
*** 관리자, 사용자는 요구사항에 대해 프로그래머에게 자문이나 정보를 얻음
*** 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못함
*** 좋은 코드를 사수하는 일은 프로그래머의 책임이기 때문

* 원초적 난제
** 기한을 맞추는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관

* 깨끗한 코드란?
** 비아네 스트롭스트룹: C++ 창시자
*** 나는 **우아하고 효율적인 코드** 를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 
의존성을 최대한 줄여야 유지보수가 쉬워진다. **오류** 는 명백한 전략에 의거해 철저히 처리한다.
성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. **깨끗한 코드는 한가지를 제대로 한다.**
*** 깨끗한 코드 => 보기에 즐거운 코드
*** 효율
*** 나쁜 코드는 나쁜 코드를 유혹함
*** 철저한 오류처리
*** 깨끗한 코드는 한가지에 집중함. 각 함수와 클래스와 모듈들은 주변 상황에 현혹되거나 오염되지 않은 채 한 길만 걷음

** 그래디 부치
*** 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다.
오히려 **명백한 추상화** 와 단순한 제어문으로 가득하다.
*** 코드는 추측이 아니라 사실에 기반해야 함
*** 반드시 필요한 내용만 담아야 함
*** 코드를 읽는 사람에게 프로그래머가 단호한 인상을 줘야 함

** 빅 데이브 토마스
*** 깨끗한 코드는 **작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 단위 테스트와 인수 테스트가 존재한다.** 깨끗한 코드에는 의미 있는 이름이 붙는다.
특정 목적을 달성하는 방법은(여러 가지가 아니라) 하나만 제공한다. 의존성은 **최소** 이며 각 의존성을 명확히 정의한다. API는 명확하며 **최소** 로 줄였다.
언어에 따라 필요한 모든 정보를 코드로만 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.
*** 가독성
*** 코드가 우아하고 가독성이 높아도 테스트 케이스가 없다면 깨끗하지 않음
*** 최소 => 큰 코드보다 작은 코드에 가치를 둠

** 마이클 페더스
*** 깨끗한 코드는 특징이 많지만 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 **언제나 누군가 주의깊게 짰다는 느낌을 준다.**
고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사람을 고려했으므로, 고칠 궁리를 하다보면 언제나 제자리로 돌아온다.
그러고는 누군가가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.
*** 깨끗한 코드는 주의 깊게 작성한 코드, 누군가 시간을 들여 깔끔하고 단정하게 정리한 코드, 세세한 사항까지 꼼꼼하게 신경 쓴 코드 => 주의를 기울인 코드

** 론 제프리스
*** 모든 테스트를 통과함
*** 중복이 없음 => 중복이 있다는 것은 코드가 아이디어를 제대로 표현하지 못한 것
*** 시스템 내 모든 설계 아이디어를 표현함
*** 클래스, 메서드, 함수 등 최대한 줄임
**** 여러 기능을 수행하는 객체나 메서드 찾음 => 여러 객체로 나누거나 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눔
*** 표현력은 의미 있는 이름도 포함 => 확정되기 전까지 이름을 여러 차례 바꿈
*** 집합에서 중복찾기
**** 추상 메서드나 추상 클래스를 만들어 실제 구현을 감쌈
**** 집합을 추상화하면 '진짜' 문제에 신경쓸 수 있음
*** **중복을 피하라, 한 기능만 수행하라, 제대로 표현하라, 작게 추상화 하라!**

** 워드 커닝햄
*** 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
*** 읽으면서 짐작한 대로 돌아가는 코드가 깨끗한 코드

===== 우리는 저자다
** 주변 코드를 읽지 않으면 새 코드를 짜지 못함. 주변 코드가 읽기 쉬우면 새 코드를 짜기 쉬움

===== 보이스카우트 규칙
** 지속적인 개선이 전문가 정신의 본질

===== 정리
** 클린코드는 좋은 코드도 소개하고 나쁜 코드도 소개하지만, 결국 내가 익히고 연습해야 됨
** 책 내용에서 객체, 메서드를 최소 코드 또는 한 가지 일을 해야한다는 내용이 자주 언급함
*** http://javacan.tistory.com/472[여러 메서드가 동일 처리 흐름을 갖는 코드 정리 예시: 클래스 추출]
*** http://www.nextree.co.kr/p6960/[객체지향 개발 5대 원리 - 단일 책임의 원칙]
** _지식으로 익히고 끝나는 것이 아니라 클린코드에서 배운 내용을 의식하고 지속적으로 적용해야 함_

=== 2. 의미 있는 름

===== 의도를 분명히 밝혀라
* 코드는 단순하지만, 의도를 파악할 수 없음 => 코드의 함축성이 문제임
* 코드 맥락이 코드 자체에 명시적으로 드러나지 않음

[source, java]
----
// * theList는 무엇이 들어있나?
// * theList에서 0번째 값은 왜 중요한가?
// * 값 4는 무슨 의미인가?
// * 함수가 반환하는 리스트 list1을 어떻게 사용하는가?
public List<int[]> getThem() {
    List<Int[]> list1 = new ArrayList<int[]>();

    for (int[] x: theList) {
        if (x[0] == 4) {
            list1.add(x);
        }
    }

    return list1;
}

// 지뢰찾기 게임이라고 가정하자
// * 게임판에서 각 칸은 단순 배열로 표현
// * 배열에서 0번째 값은 칸 상태를 의미
// * 값 4는 깃발이 꽂힌 상태를 가리킴
public List<int[]> getFlaggedCells() {
    List<Int[]> flaggedCells = new ArrayList<int[]>();

    for (int[] cell: gameBoard) {
        if (cell[STATUS_VALUE] == FLAGGED) {
            flaggedCells.add(cell);
        }
    }

    return flaggedCells;
}

// 조금 더 개선해봄
// * int[] -> Cell 클래스
// * cell[STATUS_VALUE] == FLAGGED -> isFlagged() 메서드
public List<Cell> getFlaggedCells() {
    List<Cell> flaggedCells = new ArrayList<Cell>();

    for (Cell cell: gameBoard) {
        if (isFlagged()) {
            flaggedCells.add(cell);
        }
    }

    return flaggedCells;
}

// 단순히 이름만 고쳤는데도 함수가 하는 일을 이해하기 쉬워짐
----

===== 그릇된 정보를 피하라
* 그릇된 정보의 예시(= 피해야 할 예시)
** 직각삼각형의 빗변 변수를 hp로 선언함
** 여러 계정을 그룹으로 묶을 때 accountList로 선언함 => 만약 바르게 바꾼다면 accountGroup, Accounts이 좋음
** 서로 흡사한 이름을 사용하지 않도록 주의함 
*** XYZControllerForEffecientHandlingOfString, 조금 떨어진 모듈에서 XYZControllerForEffecientStorageOfStrings을 사용함
** 일관성이 떨어지는 표기법
** 소문자 L, 대문자 O를 사용함 => 소문자 l은 숫자 1, 대문자 O은 숫자 0처럼 보임

[source, java]
----
int a = 1;
if (O == l)
    a = 01;
else 
    l = 01;
----

===== 의미 있게 구분하라
* 컴파일러나 인터프리터만 통과하려는 생각은 문제가 됨. 의도가 드러나게 작성해야 함
* -Info, -Data 도 의미가 불분명한 이름
* a1, a2 ... aN 같은 이름도 의도가 드러나지 않음

[source, java]
----
public static void copyChars(char a1[], char a2[]) {
    for (int i = 0; i < a1.length ; i++) {
        a2[i] = a1[i];
    }
} 
----

===== 발음하기 쉬운 이름을 사용하라

===== 검색하기 쉬운 이름을 사용하라 
* 이름 길이는 범위 크기에 비례해야 함

===== 인코딩을 피하라
* 인코딩한 이름은 거의 발음하기 어려우며 오타가 생김

===== 헝가리식 표기법
* 헝가리식 표기법이나 기타 인코딩 방식이 오히려 방해가 됨

----
PhoneNumber phoneString;
// 타입이 바뀌어도 이름이 바뀌지 않으므로 헷갈림
----

* 멤버 변수 접두어
** m_- 이라는 접두어를 붙이지 마라

* 인터페이스 클래스와 구현 클래스
** ShapeFactoryImp, CShapeFactory, IShapeFactory보다 ShapeFactory가 좋음

===== 자신의 기억력을 자랑하지 마라
* 루프에서 반복 횟수 변수는 i, j, k 같이 한 글자를 사용하지만, 그 이외에 사용하는 것은 적절하지 못함
* 전문가 프로그래머는 자신의 능력을 좋은 방향으로 사용해 남들이 이해하는 코드를 내놓음

===== 클래스, 객체 이름
* 명사나 명사구가 적절함

===== 메서드 이름
* 동사나 동사구가 적절함
* 생성자를 중복 정의 할 때 정적 팩토리 메서드를 사용함
* 메서드는 인수를 설명하는 이름을 사용함

===== 기발한 이름은 피하라

===== 한 개념에 한 단어를 사용하라
* 추상적인 개념 하나에 단어 하나를 선택해 이를 고수함
** 예를 들어 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 사용하면 혼란스러움
* 메서드 이름은 독자적이고 일관적이어야 함

===== 말장난을 하지 마라

===== 해법 영역에서 가져온 이름을 사용하라
* 코드를 읽을 사람은 프로그래머 이기 때문에 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용하는 것은 괜찮음
** AccountVisitor, JobQueue 등

===== 문제 영역에서 가져온 이름을 사용하라
* 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 가져와야 함

===== 의미 있는 맥락을 추가하라 
* Address를 나타내는 firstName, lastName, street, houseNumber, city, state, zipcode 변수들이 있음
** state 변수가 주소 일부라는 사실을 금방 알 수 있을까?
** addrFirstName, addrLastName, addrState ...
** 더 좋은 방법은 Address 라는 클래스를 생성함
** 맥락이 불분명한 변수명은 피해야 함

===== 불필요한 맥락을 없애라
* 일반적으로 짧은 이름이 긴 이름보다 좋음. 그러나 의미가 분명한 경우에 한해서 사용해야 함

===== 정리
* 의미 있는 이름을 지으려고 노력하면서 코드의 가독성이 좋아지는 것을 느껴보자
* 프로그래밍의 정석에서 배운 루프백을 적용해보자
* 애플 문서나 다른 사람들의 코드를 보고 이름을 어떻게 짓는지 확인해보자
* _생성자를 중복 정의 할 때 정적 팩토리 메서드를 사용함_ 은 무슨 의미인가 ?
** 클래스의 인스턴스(instance)를 생성하도록 하는 일반적인 방법은 public 생성자(constructor)을 제공하는 것
** https://rangken.gitbooks.io/javastudy/content/chapter2/item1.html[Effective Java - 기본 생성자보다 Static 팩토리 메서드를 만들어라]
